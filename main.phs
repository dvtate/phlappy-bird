"../postfix-haskell/planning/stdlib/prelude.phs" include use
"../postfix-haskell/planning/stdlib/bits.phs" include use
"../postfix-haskell/planning/stdlib/math.phs" include use
"../postfix-haskell/planning/stdlib/static_mem.phs" include use

# Generate random float from [0,1)
{
    { } { F32 } Arrow { "js" "Math.random" } import @
} $rand =

{ # Detect collision between 2 rectangles
    {   $x1 $y1 $w1 $h1
        $x2 $y2 $w2 $h2 } =
    x1 x2 w2 + <
    x1 w1 + x2 > &&
    y1 y2 h2 + < &&
    y1 h1 + y2 > &&
} $rect_collide =

{ { $x $y $w $h $color } =
    # Set fill
    color 0xff0000 and 16 >> $r =
    color 0xff00 and 8 >> $g =
    color 0xff and $b =
    r g b { Void I32 I32 I32 } { Void } Arrow { "js" "setFill" } import @

    # Draw rectangle
    x y w h
    { Void x type y type w type h type } { Void } Arrow
    { "js" "contextFillRect" } import @
} $Game.draw_rect =


768 $Game.WIDTH =
1024 $Game.HEIGHT =
0.3f $Game.GRAVITY =

##
# Gates/pipes
##

{
    I32 # x
    F32 # y
} pack class $Gate =
150 $Gate.GAP =
100 $Gate.WIDTH =
10 $Gate.LIP_WIDTH =
50 $Gate.LIP_HEIGHT =
100.0f $Gate.HIDDEN =

{ type Gate == } { unpack pop } $Gate.x fun
{ type Gate == } { unpack swap pop } $Gate.y fun

{
    unpack { $x $y } =
    { x 1 - y } pack Gate make
} $Gate.update =
{
    rand $n =
    {
        Game.WIDTH
        n Game.HEIGHT Gate.GAP - F32 cast *
    } pack Gate make
} $Gate.respawn =

{ pop type Gate == } {
    $addr = unpack { $x $y } =
    x addr static_init
    y addr 4 + static_init
} $static_init fun
{ pop type Gate == } {
    $addr = unpack { $x $y } =
    x addr store
    y addr 4 + store
} $store fun

{ type Gate == } { unpack { $x $y } =
    x
    0
    Gate.WIDTH Gate.LIP_WIDTH 2 * +
    y
} $Gate.collide_rect_top fun
{ type Gate == } { unpack { $x $y } =
    x
    y Gate.GAP +
    Gate.WIDTH Gate.LIP_WIDTH 2 * +
    Game.HEIGHT y -
} $Gate.collide_rect_bot fun

{ type Gate == } { pop } $Gate.draw fun
{ unpack { $x $y } =
    x Gate.WIDTH neg > y Gate.HIDDEN != &&
} {
    unpack { $x $y } =
    x Gate.LIP_WIDTH +
    0
    Gate.WIDTH Gate.LIP_WIDTH 2 * -
    y Gate.LIP_HEIGHT -
    0x55ff55
        Game.draw_rect

    x
    y Gate.LIP_HEIGHT -
    Gate.WIDTH
    Gate.LIP_HEIGHT
    0x11ff11
        Game.draw_rect

    x
    y Gate.GAP +
    Gate.WIDTH
    Gate.LIP_HEIGHT
    0x11ff11
        Game.draw_rect

    x Gate.LIP_WIDTH +
    y Gate.GAP Gate.LIP_HEIGHT + +
    Gate.WIDTH Gate.LIP_WIDTH 2 * -
    Game.HEIGHT Gate.GAP - Gate.LIP_HEIGHT - y -
    0x55ff55
        Game.draw_rect
} $Gate.draw fun

##
# Bird
##

{
    F32 # y
    F32 # dy
} pack class $Bird =

{ type Bird == } { unpack pop } $Bird.y fun
{ type Bird == } { unpack pop } $Bird.dy fun
50 $Bird.X =
40 $Bird.WIDTH =
45 $Bird.HEIGHT =

{
    unpack pop $y =
    Bird.X y Bird.WIDTH Bird.HEIGHT
} $Bird.collide_rect =

{ unpack { $y $dy } =
    {
        y dy +
        dy Game.GRAVITY +
    } pack Bird make
} $Bird.update =

{ # Draw a thwomp where the bird is
    unpack { $y $dy } =
    Bird.X y Bird.WIDTH Bird.HEIGHT
    { Void I32 F32 I32 I32 } { Void } Arrow
    { "js" "drawThwomp" } import @
} $Bird.draw =

# Memory stuff
{ pop type Bird == } {
    $addr = unpack { $y $dy } =
    y addr static_init
    dy addr 4 + static_init
} $static_init fun
{ pop type Bird == } {
    $addr = unpack { $y $dy } =
    y addr store
    dy addr 4 + store
} $store fun

# Initialize static memory fields
8 static_region $Game.BIRD_ADDR =
8 static_region $Game.GATE1_ADDR =
8 static_region $Game.GATE2_ADDR =
{ 10.0f 0.0f } pack Bird make Game.BIRD_ADDR static_init
{ Gate.WIDTH neg Gate.HIDDEN } pack Gate make
dup Game.GATE1_ADDR static_init
Game.GATE2_ADDR static_init

# Load state from static memory
{
    {   Game.BIRD_ADDR "f32.load" asm
        Game.BIRD_ADDR 4 + "f32.load" asm
    } pack Bird make
    {   Game.GATE1_ADDR "i32.load" asm
        Game.GATE1_ADDR 4 + "f32.load" asm
    } pack Gate make
    {   Game.GATE2_ADDR "i32.load" asm
        Game.GATE2_ADDR 4 + "f32.load" asm
    } pack Gate make
} $Game.load =

{
    # Get state
    Game.load { $bird $g1 $g2 } =

    # Clear scene
    0 0 Game.WIDTH Game.HEIGHT
    { Void I32 I32 I32 I32 } { Void } Arrow
    { "js" "contextClearRect" } import @

    # Draw scene
    g1 Gate.draw
    g2 Gate.draw
    bird Bird.draw
} $Game.draw =

{
    { $b $g1 $g2 } =

    #{ Void I32 I32 } { Void } Arrow { "js" "console.log" } import $log2 =
    #{ Void I32 I32 I32 F32 } { Void } Arrow { "js" "console.log" } import $log4 =
    #g1 Gate.collide_rect_top log4
    #1 b Bird.y 0 < log2
    #2 b Bird.y Game.HEIGHT Bird.HEIGHT - > log2
    #3 g1 Gate.collide_rect_top b Bird.collide_rect rect_collide log2
    #4 g1 Gate.collide_rect_bot b Bird.collide_rect rect_collide log2
    #5 g2 Gate.collide_rect_top b Bird.collide_rect rect_collide log2
    #6 g2 Gate.collide_rect_bot b Bird.collide_rect rect_collide log2

    b Bird.y 0 <
    b Bird.y Game.HEIGHT Bird.HEIGHT - > ||
    g1 Gate.collide_rect_top b Bird.collide_rect rect_collide ||
    g1 Gate.collide_rect_bot b Bird.collide_rect rect_collide ||
    g2 Gate.collide_rect_top b Bird.collide_rect rect_collide ||
    g2 Gate.collide_rect_bot b Bird.collide_rect rect_collide ||
} $Game.is_over =

{
    {
        Gate.update $g2 = g2 unpack { $ay $ady } =
        Gate.update $g1 = g1 unpack { $by $bdy } =
        { true } {
            g1 Game.GATE1_ADDR store
            g2 Game.GATE2_ADDR store
        } $act fun
        { ay Gate.WIDTH neg < by Game.WIDTH 2 / < && } {
            Gate.respawn Game.GATE1_ADDR store
            g2 Game.GATE2_ADDR store
        } $act fun
        { by Gate.WIDTH neg < ay Game.WIDTH 2 / < && } {
            g1 Game.GATE1_ADDR store
            Gate.respawn Game.GATE2_ADDR store
        } $act fun
        act
    } $update_gates =

    Game.load Game.is_over { Void I32 } { Void } Arrow { "js" "console.log" } import @

    # Get state
    { true } {
        # Update state
        Game.load { $b $g1 $g2 } =
        b Bird.update Game.BIRD_ADDR store
        g1 g2 update_gates
    } $branch fun
    { Game.load Game.is_over } {
        # Do nothing if game already over
    } $branch fun
    branch
} $Game.update =


{ Void } { Game.draw } $draw export
{ Void } { Game.update } $update export

{ Void } {
    Game.load pop pop $bird =
    bird unpack pop $y =
    { y -5.0f } pack Bird make Game.BIRD_ADDR store
} $flap export

{ Void } {
    Game.draw
    Game.update

    # Await next frame
    { Void } { Void } Arrow { "js" "nextFrame" } import @
} $loop export

{ Void } {
    # Clear scene
    0 0 Game.WIDTH Game.HEIGHT
    { Void I32 I32 I32 I32 } { Void Void } Arrow
    { "js" "contextClearRect" } import @ pop

    { 323.0f 0.0f } pack Bird make Bird.draw

    Gate.respawn $gg2 =
    { gg2 unpack swap pop 50 swap } pack Gate make Gate.draw

    Gate.respawn $gg =
    { gg unpack swap pop 280 swap } pack Gate make Gate.draw

} $test export
