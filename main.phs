"../postfix-haskell/planning/stdlib/prelude.phs" include use
"../postfix-haskell/planning/stdlib/bits.phs" include use
"../postfix-haskell/planning/stdlib/math.phs" include use
"../postfix-haskell/planning/stdlib/static_mem.phs" include use

# Generate random float from [0,1)
{
    { Void } { Void F32 } Arrow { "js" "Math.random" } import @
} $rand =

{ # Detect collision between 2 rectangles
    {   $x1 $y1 $w1 $h1
        $x2 $y2 $w2 $h2 } =
    x1 x2 w2 + <
    x1 w1 + x2 > &&
    y1 y2 h2 + < &&
    y1 h1 + y2 > &&
} $rect_collide =

{ { $x $y $w $h $color } =
    # Set fill
    color 0xff0000 and 16 >> $r =
    color 0xff00 and 8 >> $g =
    color 0xff and $b =
    r g b { Void I32 I32 I32 } { Void } Arrow { "js" "setFill" } import @

    # Draw rectangle
    x y w h
    { Void x type y type w type h type } { Void } Arrow
    { "js" "contextFillRect" } import @
} $Game.draw_rect =


400 $Game.WIDTH =
700 $Game.HEIGHT =
0.5f $Game.GRAVITY =

##
# Gates/pipes
##

{
    I32 # x
    F32 # y
} pack class $Gate =
150 $Gate.GAP =
100 $Gate.WIDTH =
10 $Gate.LIP_WIDTH =
50 $Gate.LIP_HEIGHT =

-0.0f $Gate.HIDDEN =

{ type Gate == } { unpack pop } $Gate.x fun
{ type Gate == } { unpack swap pop } $Gate.y fun

{
    dup $g = unpack { $x $y } =
    { g type Gate == } { x 1 - y } $act fun
    { x Gate.WIDTH neg < y Gate.HIDDEN == || } { x Gate.HIDDEN } $act fun
    { act } pack Gate make
} $Gate.update =
{
    rand $n =
    {
        Game.WIDTH
        n Game.HEIGHT Gate.GAP - F32 cast *
    } pack Gate make
} $Gate.spawn =

{ pop type Gate == } {
    $addr = unpack { $x $y } =
    x addr static_init
    y addr 4 + static_init
} $static_init fun
{ pop type Gate == } {
    $addr = unpack { $x $y } =
    x addr store
    y addr 4 + store
} $store fun

{ type Gate == } { unpack { $x $y } =
    x
    0
    Gate.WIDTH Gate.LIP_WIDTH 2 * +
    y
} $Gate.collide_rect_top fun
{ type Gate == } { unpack { $x $y } =
    x
    y Gate.GAP +
    Gate.WIDTH Gate.LIP_WIDTH 2 * +
    Game.HEIGHT y -
} $Gate.collide_rect_bot fun

{ type Gate == } { pop } $Gate.draw fun
{ unpack { $x $y } =
    x Gate.WIDTH neg > y Gate.HIDDEN != &&
} {
    unpack { $x $y } =
    x Gate.LIP_WIDTH +
    0
    Gate.WIDTH Gate.LIP_WIDTH 2 * -
    y Gate.LIP_HEIGHT -
    0x55ff55
        Game.draw_rect

    x
    y Gate.LIP_HEIGHT -
    Gate.WIDTH
    Gate.LIP_HEIGHT
    0x11ff11
        Game.draw_rect

    x
    y Gate.GAP +
    Gate.WIDTH
    Gate.LIP_HEIGHT
    0x11ff11
        Game.draw_rect

    x Gate.LIP_WIDTH +
    y Gate.GAP Gate.LIP_HEIGHT + +
    Gate.WIDTH Gate.LIP_WIDTH 2 * -
    Game.HEIGHT Gate.GAP - Gate.LIP_HEIGHT - y -
    0x55ff55
        Game.draw_rect
} $Gate.draw fun

##
# Bird
##

{
    F32 # y
    F32 # dy
} pack class $Bird =

{ type Bird == } { unpack pop } $Bird.y fun
{ type Bird == } { unpack pop } $Bird.dy fun
50 $Bird.X =
45 $Bird.HEIGHT =
40 $Bird.WIDTH =

{ unpack { $y $dy } =
    {
        y dy +
        dy Game.GRAVITY +
    } pack Bird make
} $Bird.update =

{
    unpack { $y $dy } =

    Bird.X y Bird.WIDTH Bird.HEIGHT
    { Void I32 F32 I32 I32 } { Void } Arrow { "js" "drawThwomp" } import @
} $Bird.draw =

# Memory stuff
{ pop type Bird == } {
    $addr = unpack { $y $dy } =
    y addr static_init
    dy addr 4 + static_init
} $static_init fun
{ pop type Bird == } {
    $addr = unpack { $y $dy } =
    y addr store
    dy addr 4 + store
} $store fun

# Initialize static memory fields
8 static_region $Game.BIRD_ADDR =
8 static_region $Game.GATE1_ADDR =
8 static_region $Game.GATE2_ADDR =
{ 10.0f 0.0f } pack Bird make Game.BIRD_ADDR static_init
{ 0 Gate.HIDDEN } pack Gate make
dup Game.GATE1_ADDR static_init
Game.GATE2_ADDR static_init

# Load state from static memory
{
    {   Game.BIRD_ADDR "f32.load" asm
        Game.BIRD_ADDR 4 + "f32.load" asm
    } pack Bird make
    {   Game.GATE1_ADDR "i32.load" asm
        Game.GATE1_ADDR 4 + "f32.load" asm
    } pack Gate make
    {   Game.GATE2_ADDR "i32.load" asm
        Game.GATE2_ADDR 4 + "f32.load" asm
    } pack Gate make
} $Game.load =

{
    # Get state
    Game.load { $bird $g1 $g2 } =

    # Clear scene
    0 0 Game.WIDTH Game.HEIGHT
    { Void I32 I32 I32 I32 } { Void Void } Arrow
    { "js" "contextClearRect" } import @ pop

    # Draw scene
    bird Bird.draw
    #g1 Gate.draw
    #g2 Gate.draw
} $Game.draw =

{
    { $b $g1 $g2 } =

    # Check collisions
    #
} $Game.is_over =

{
    # Get state
    Game.load { $b $g1 $g2 } =

    # Save state
    b Bird.update $_b =
    g1 Gate.update $_g1 =
    g2 Gate.update $_g2 =
    _b Game.BIRD_ADDR store
    _g1 Game.GATE1_ADDR store
    _g2 Game.GATE2_ADDR store
} $Game.update =


{ Void } { Game.draw } $draw export
{ Void } { Game.update } $update export
{ Void } {
    Game.load pop pop $bird =
    bird unpack pop $y =
    { y 20.0f } pack Bird make Game.BIRD_ADDR store
} $flap export
{ Void } {
    Game.draw
    Game.update

    # Await next frame
    { Void } { Void } Arrow { "js" "nextFrame" } import @
} $loop export


{ Void } {
    # Clear scene
    0 0 Game.WIDTH Game.HEIGHT
    { Void I32 I32 I32 I32 } { Void Void } Arrow
    { "js" "contextClearRect" } import @ pop

    { 323.0f 0.0f } pack Bird make Bird.draw

    Gate.spawn $gg2 =
    { gg2 unpack swap pop 50 swap } pack Gate make Gate.draw

    Gate.spawn $gg =
    { gg unpack swap pop 280 swap } pack Gate make Gate.draw

} $test export
