"./node_modules/postfix-haskell/planning/stdlib/prelude.phs" include use
"./node_modules/postfix-haskell/planning/stdlib/bits.phs" include use
"./node_modules/postfix-haskell/planning/stdlib/math.phs" include use
"./node_modules/postfix-haskell/planning/stdlib/static_mem.phs" include use

# Generate random f32 from [0,1)
{ } { F32 } Arrow { "js" "Math.random" } import $rand =

{ # Detect collision between 2 rectangles
    {   $x1 $y1 $w1 $h1
        $x2 $y2 $w2 $h2 } =
    x1 x2 w2 + <
    x1 w1 + x2 > &&
    y1 y2 h2 + < &&
    y1 h1 + y2 > &&
} $rect_collide =

# Draw a rectangle onto the canvas
{ { $x $y $w $h $color } =
    # Set fill
    color 0xff0000 and 16 >> $r =
    color 0xff00 and 8 >> $g =
    color 0xff and $b =
    r g b { Void I32 I32 I32 } { Void } Arrow { "js" "setFill" } import @

    # Draw rectangle
    x y w h
    { Void x type y type w type h type } { Void } Arrow
    { "js" "contextFillRect" } import @
} $Game.draw_rect =

# Canvas dimensions
768 $Game.WIDTH =
1024 $Game.HEIGHT =

# Acceration due to gravity (pixels/frame^2)
0.3f $Game.GRAVITY =

##
# Gate - combination of a top pipe and bottom pipe
##

{   I32 # x - position on the screen
    F32 # y - height of the opening
} pack class $Gate =
{ type Gate == } { unpack pop } $.x fun
{ type Gate == } { unpack swap pop } $.y fun

# Gate constant dimensions
150 $Gate.GAP =         # Gap between top and bottom pipes
100 $Gate.WIDTH =       # Width of the pipe
10 $Gate.LIP_WIDTH =    # Lip overhang
50 $Gate.LIP_HEIGHT =   # Height of the lip sections

{ # Move gate to the left
    unpack { $x $y } =
    { x 1 - y } pack Gate make
} $Gate.update =

{ # Randomly generate a gate
    rand $n =
    {   Game.WIDTH
        n Game.HEIGHT Gate.GAP - F32 cast *
    } pack Gate make
} $Gate.respawn =

# Overload operators for static memory
{ pop type Gate == } {
    $addr = unpack { $x $y } =
    x addr static_init
    y addr 4 + static_init
} $static_init fun
{ pop type Gate == } {
    $addr = unpack { $x $y } =
    x addr store
    y addr 4 + store
} $store fun

# Rectangular Hitboxes
{ unpack { $x $y } =
    x
    0
    Gate.WIDTH
    y
} $Gate.hitbox_top =
{ unpack { $x $y } =
    x
    y Gate.GAP +
    Gate.WIDTH
    Game.HEIGHT y -
} $Gate.hitbox_bot =

{ # Draw gate onto canvas
    unpack { $x $y } =
    # Top pipe
    x Gate.LIP_WIDTH +
    0
    Gate.WIDTH Gate.LIP_WIDTH 2 * -
    y Gate.LIP_HEIGHT -
    0x55ff55
        Game.draw_rect

    # Top lip
    x
    y Gate.LIP_HEIGHT -
    Gate.WIDTH
    Gate.LIP_HEIGHT
    0x11ff11
        Game.draw_rect

    # Bottom lip
    x
    y Gate.GAP +
    Gate.WIDTH
    Gate.LIP_HEIGHT
    0x11ff11
        Game.draw_rect

    # Bottom pipe
    x Gate.LIP_WIDTH +
    y Gate.GAP Gate.LIP_HEIGHT + +
    Gate.WIDTH Gate.LIP_WIDTH 2 * -
    Game.HEIGHT Gate.GAP - Gate.LIP_HEIGHT - y -
    0x55ff55
        Game.draw_rect
} $Gate.draw =

##
# Bird - the thwomp
##
{   F32 # y
    F32 # dy
} pack class $Bird =
{ type Bird == } { unpack pop } $.y fun
{ type Bird == } { unpack pop } $.dy fun

# Bird constant dimensions
200 $Bird.X =       # Bird does not move side to side
40 $Bird.WIDTH =    # Width of bird sprite
45 $Bird.HEIGHT =   # Height of bird sprite

{ # Get hitbox
    unpack pop $y =
    Bird.X y Bird.WIDTH 3 - Bird.HEIGHT 3 -
} $Bird.hitbox =

{ # Apply gravity to the bird
    unpack { $y $dy } =
    {   y dy +
        dy Game.GRAVITY +
    } pack Bird make
} $Bird.update =

{ # Draw a thwomp where the bird is
    unpack { $y $dy } =
    Bird.X y Bird.WIDTH Bird.HEIGHT
    { Void I32 F32 I32 I32 } { Void } Arrow
    { "js" "drawThwomp" } import @
} $Bird.draw =

# Overload static memory operators
{ pop type Bird == } {
    $addr = unpack { $y $dy } =
    y addr static_init
    dy addr 4 + static_init
} $static_init fun
{ pop type Bird == } {
    $addr = unpack { $y $dy } =
    y addr store
    dy addr 4 + store
} $store fun

# Initialize static memory
8 static_region $Game.BIRD_ADDR =
8 static_region $Game.GATE1_ADDR =
8 static_region $Game.GATE2_ADDR =
{ 10.0f 0.0f } pack Bird make Game.BIRD_ADDR static_init
{ Gate.WIDTH neg 100.0f } pack Gate make
dup Game.GATE1_ADDR static_init
Game.GATE2_ADDR static_init

{ # Load game state from static memory
    {   Game.BIRD_ADDR "f32.load" asm
        Game.BIRD_ADDR 4 + "f32.load" asm
    } pack Bird make
    {   Game.GATE1_ADDR "i32.load" asm
        Game.GATE1_ADDR 4 + "f32.load" asm
    } pack Gate make
    {   Game.GATE2_ADDR "i32.load" asm
        Game.GATE2_ADDR 4 + "f32.load" asm
    } pack Gate make
} $Game.load =

{ # Draw game onto canvas
    # Get state
    Game.load { $bird $g1 $g2 } =

    # Clear scene
    0 0 Game.WIDTH Game.HEIGHT
    { Void I32 I32 I32 I32 } { Void } Arrow
    { "js" "contextClearRect" } import @

    # Draw scene
    g1 Gate.draw
    g2 Gate.draw
    bird Bird.draw
} $Game.draw =

{ # Check if the bird is in a bad spot
    { $b $g1 $g2 } =
    b .y 0 <
    b .y Game.HEIGHT Bird.HEIGHT - > ||
    g1 Gate.hitbox_top b Bird.hitbox rect_collide ||
    g1 Gate.hitbox_bot b Bird.hitbox rect_collide ||
    g2 Gate.hitbox_top b Bird.hitbox rect_collide ||
    g2 Gate.hitbox_bot b Bird.hitbox rect_collide ||
} $Game.is_over =

{ # If game not over, move things
    {
        Gate.update $g2 = g2 unpack { $y2 $dy2 } =
        Gate.update $g1 = g1 unpack { $y1 $dy1 } =
        { true } {
            # No respawns
            g1 Game.GATE1_ADDR store
            g2 Game.GATE2_ADDR store
        } $act fun
        { y1 Gate.WIDTH neg < y2 Game.WIDTH 2 / < && } {
            # Gate 1 respawn
            Gate.respawn Game.GATE1_ADDR store
            g2 Game.GATE2_ADDR store
        } $act fun
        { y2 Gate.WIDTH neg < y1 Game.WIDTH 2 / < && } {
            # Gate2 respawn
            g1 Game.GATE1_ADDR store
            Gate.respawn Game.GATE2_ADDR store
        } $act fun
        act
    } $update_gates =

    # Get state
    { true } {
        # Update state
        Game.load { $b $g1 $g2 } =
        b Bird.update Game.BIRD_ADDR store
        g1 g2 update_gates
    } $branch fun
    { Game.load Game.is_over } {
        # Do nothing if game already over
    } $branch fun
    branch
} $Game.update =

# Export tap handler
{ Void } {
    Game.load pop pop $bird =
    bird unpack pop $y =
    { y -6.0f } pack Bird make Game.BIRD_ADDR store
} $flap export

# Export main game loop
{ Void } {
    # This is a sketchy workaround for a bug
    Game.draw $draw =
    {} pack Game.update
    draw swap

    # Await next frame
    { Void Void } { Void } Arrow { "js" "nextFrame" } import @
} $loop export

# Export some functions for debugging
{ Void } { Game.draw } $draw export
{ Void } { Game.update } $update export
{ Void } { Game.load Game.is_over } $gameOver export